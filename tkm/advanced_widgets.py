##################################################
# Advanced Widgets
##################################################

# Contains more advanced Widgets to be used.
# All Widgets here are to inherit a Widget from base_widgets.py

# The point of advanced Widgets is to provide more application-specific Widgets
# that are commonly used and are pre-configured for ease of development.

# If a Widget is to contain more than one Widget, then the class should inherit the
# Frame_Widget, and then wrap the inner child Widgets in this Frame_Widget.

import tkinter as tk
from tkinter import *
from tkinter import filedialog
from tkinter.ttk import *

from .base_widgets import Frame_Widget, Button_Widget, Dropdown_Widget
import logging

class Button_File_Opener_Widget(Button_Widget):
    """The widget containing a button that handles file opening.

    Inherits the Button_Widget object, and will write to a target Widget
    when the files are loaded. This target Widget may be set in this Widget's 
    constructor, or separately later on.
    """
    def __init__(self, id, text='', parent=None, target_widget=None,\
        column_start=0, column_end=0, row_start=0, row_end=0,\
            padx=5, pady=5, ipadx=1, ipady=1, sticky='nsew',\
                font='', font_size=11, font_color='#000',\
                    image=None):
        super().__init__(id=str(id), parent=parent, column_start=column_start, \
            column_end=column_end, row_start=row_start, row_end=row_end,\
                padx=padx, pady=pady, ipadx=ipadx, ipady=ipady, sticky=sticky,\
                    image=image, text=text, function=self.__open_filenames,\
                        font=font, font_size=font_size, font_color=font_color)
        
        self.__target_widget = target_widget
        self.bind_function(self.__open_filenames)

    def __open_filenames(self):
        """Uses tkinter filedialog to open files, and then write
        to the target Widget. Each file is separated by a newline.

        Throws a TypeError exception if no Widget is binded.
        """
        # writes the tuple generated by askopenfilenames as a string
        if self.__target_widget is None:
            raise TypeError(str(self.get_id()) + ' has no target Widget binded\
                 and will not write to any Widget.')
                    
        files = filedialog.askopenfilenames()
        self.__target_widget.flush()
        for file in files:
            self.__target_widget.write(file)
            self.__target_widget.write('\n')

    def set_target_widget(self, widget):
        """Sets the Widget that this Widget will write to when a file
        is loaded.

        Widget must contain a flush and write function upon setting.
        """
        assert hasattr(widget, 'flush') and hasattr(widget, 'write')
        self.__target_widget = widget

class Dropdown_With_Button_Widget(Frame_Widget):
    """A custom Frame_Widget containing a Button Widget that interacts with the
    selected value in a Dropdown Widget.

    Grid options in this class's constructor refers to THIS Widget only.
    Editing of child Widgets is done via getters for the Widget.

    This Widget needs to be binded to a Widget that 
    """
    # TODO: add font color to text label
    def __init__(self, id, text='', parent=None, target_widget=None,\
        column_start=0, column_end=15, row_start=0,\
            padx=5, pady=5, ipadx=1, ipady=1, sticky='w',\
                font='', font_size=11, font_color='#000',\
                    values=None):
        super().__init__(id=str(id), parent=parent, column_start=column_start, \
            column_end=column_end, row_start=row_start, row_end=row_start + 3,\
                padx=padx, pady=pady, ipadx=ipadx, ipady=ipady, sticky=sticky)

        self.__target_widget = target_widget
        self.__text = text

        self._widget_label = Label_Text_Widget(self.get_id() + '_label', \
            text=text, parent=self.get_widget(), column_start=column_start,\
                column_end=column_start + 3, row_start=row_start, row_end=row_start + 1,\
                    padx=0, pady=0, ipadx=0, ipady=0, sticky='w',\
                        font=font, font_size=font_size)
        
        self._widget_dropdown = Dropdown_Widget(self.get_id() + '_dropdown', \
            parent=self.get_widget(), column_start=column_start + 4, column_end=column_end - 2,\
                row_start=row_start, row_end=row_start + 1,\
                    pady=pady, values=values, padx=0, sticky='ew')

        self._widget_button = Button_Widget(self.get_id() + '_button',\
            parent=self.get_widget(), text='Add/Remove', \
                column_start=column_end-1, column_end=column_end,\
                    row_start=row_start, row_end=row_start + 1,\
                        padx=0, ipadx=0, pady=pady, function=None, sticky='e')

        if parent is not None:
            self.setup(parent)

    # override
    def __init_widget(self, parent):
        self.set_widget(tk.Frame(parent, height=self.get_height(), \
            width=self.get_width(), bg=self.get_bg(), \
                borderwidth=self.get_borderwidth()))
        self.set_init()

    def setup(self, parent):
        """Inits the widget to a parent widget.
        """
        self.__init_widget(parent)
        self.add_widget(self._widget_label)
        self.add_widget(self._widget_dropdown)
        self.add_widget(self._widget_button)
        self._widget_button.bind_function(self.__add_value)
        self.init_grid()

    def __add_value(self):
        """Reads value from Dropdown, and then writes it to the target Widget.

        Method call to write to Widget is based on __target_widget type.
        """
        value = self._widget_dropdown.get_selected_value()
        if value != '' and value in self._widget_dropdown.get_values():
            if type(self.__target_widget) is Textbox_Dictionary_Widget:
                self.__target_widget.write(self.__text, str(value))
                self._widget_dropdown.flush()
            else:
                self.__target_widget.write(value)
        else:
            self._widget_dropdown.flush()

    def flush(self):
        self._widget_dropdown.flush()

    def bind_function(self, function):
        self._widget_button.bind_function(function)

    def resize(self, label_width, dropdown_width):
        """Resizes the Widgets based on the given args.
        """
        self._widget_label.set_width(label_width)
        self._widget_dropdown.set_width(dropdown_width)
        self._widget_label.init_grid()
        self._widget_dropdown.init_grid()

    # setters
    def set_values(self, values):
        self._widget_dropdown.set_values(values)

    def set_row(self, value):
        self._widget_dropdown.set_row(value)
        self._widget_button.set_row(value)

    def set_label_width(self, value):
        self._widget_label.set_width(value)

    # getters
    def get_label_widget(self):
        return self._widget_label

    def get_button_widget(self):
        return self._widget_button

    def get_dropdown_widget(self):
        return self._widget_dropdown

    def get_button_widget(self):
        return self._widget_button

    def get_current_selected_value(self):
        return self._widget_dropdown.get_selected_value()

class Textbox_Dictionary_Widget(Frame_Widget):
    """A custom Frame_Widget that contains a custom Textbox Dictionary Widget.

    This Widget contains a Dictionary, that we can add key value pairs onto.
    Each value is a List of strings, and adding a Key-Value pair with an 
    existing Key appends the value to the List.
    """
    def __init__(self, id, parent=None, column_start=0, column_end=10, row_start=0,\
        row_end=10, padx=1, pady=1, ipadx=1, ipady=1, sticky='ew'):
        super().__init__(id=str(id), parent=parent, column_start=column_start, \
            column_end=column_end, row_start=row_start, row_end=row_end,\
                padx=padx, pady=pady, ipadx=ipadx, ipady=ipady, sticky=sticky)

        self._widget_textbox = Textbox_Widget(self.get_id() + '_textbox', \
            parent=self.get_widget(), column_start=column_start,\
                column_end=column_end, row_start=row_start, row_end=row_end,\
                    padx=5, pady=0, ipadx=0, ipady=0, sticky=sticky)

        self.__dict = {}

        if parent is not None:
            self.setup(parent)

    # override
    def __init_widget(self, parent):
        self.set_widget(tk.Frame(parent, height=self.get_height(), \
            width=self.get_width(), bg=self.get_bg(), \
                borderwidth=self.get_borderwidth()))
        self.set_init()

    def setup(self, parent):
        """Inits the widget to a parent widget.
        """
        self.__init_widget(parent)
        self.add_widget(self._widget_textbox)
        self.init_grid()

    def write(self, key, value):
        """Queries if the Key-Value pair exists in the Widget, then writes
        or deletes depending if it does not exist or exists in this widget.

        Adds if not found, deletes if found.
        """
        if key in self.__dict.keys():
            if value not in self.__dict[key]:
                self.__dict[key].append(value)
            else:
                self.__dict[key].remove(value)
                if len(self.__dict[key]) == 0:
                    del self.__dict[key]
        else:
            self.__dict[key] = [value, ]
        self.__update_textbox()

    def add_key_value_pair(self, key, value):
        """Adds a Key-Value pair to the Widget and updates it.

        If Key is not in the Dictionary of the Widget, a List with the Value
        is added. If the key exists, then the Value is appended to this List.
        """
        if key in self.__dict.keys() and value not in self.__dict[key]:
            self.__dict[key].append(value)
        else:
            self.__dict[key] = [value, ]
        self.__update_textbox()

    def remove_key_value_pair(self, key, value):
        """Removes a Key-Value pair from the Widget.
        """
        if key in self.__dict.keys():
            if value in self.__dict[key]:
                self.__dict[key].remove(value)
            else:
                raise KeyError('Value does not exist.')
        else:
            raise KeyError('Key does not exist.')

    def flush(self):
        self.__dict = {}
        self.__update_textbox()

    def __update_textbox(self):
        self._widget_textbox.flush()
        # iterate through the keys and add the values
        for key in self.__dict.keys():
            self._widget_textbox.write(str(key) + ':\n')
            for value in self.__dict[key]:
                self._widget_textbox.write(str(value) + '\n')

    def set_textbox_width(self, value):
        self._widget_textbox.set_width(value)

    def set_textbox_height(self, value):
        self._widget_textbox.set_height(value)

    def get_dict(self):
        return self.__dict

    def get_keys(self):
        return self.__dict.keys()

    def get_text_box(self):
        return self._widget_textbox

class Dropdown_Multiselect_Widget(Frame_Widget):
    """A custom Frame_Widget containing multiple Dropdown_With_Button_Widgets
    which interacts with a Textbox_Dictionary_Widget.

    Value selected by Dropdown_With_Button_Widget will be written to
    Textbox_Dictionary_Widget.
    """
    def __init__(self, id, parent=None, column_start=0, column_end=10, row_start=0,\
        padx=1, pady=1, ipadx=1, ipady=1, sticky='ew',\
            filters=None, bg=None, borderwidth=0, textbox_width=34):
        """

        NOTE: Initial Dropdown_With_Button_Widget values will need to be
        written to separately after initialization.

        Args:
            values (List): The List of strings of different values to be used
            for the filters in this Widget.
            textbox_width (int): The width of the textbox. This affects the actual
            size of the Widget.
        """
        super().__init__(id=str(id), parent=parent, column_start=column_start,\
            column_end=column_end, row_start=row_start,\
                row_end=row_start + (len(filters) * 4) + 24,\
                    padx=padx, pady=pady, ipadx=ipadx, ipady=ipady,\
                        sticky=sticky, bg=bg, borderwidth=borderwidth)

        self.__dropdown_dict = {}
        self.__filters = filters

        self.__filter_label = Label_Text_Widget(self.get_id() + '_label',\
            'Filters', column_start=column_start, column_end=column_end,\
                row_start=row_start, row_end=row_start + 1,\
                    ipadx=3, ipady=3, font_size=15, sticky='nsew')

        self.__filter_textbox = Textbox_Dictionary_Widget(\
            self.get_id() + '_textbox', column_start=column_start,\
                column_end=column_end, row_start=row_start + (len(filters) * 4) + 16,\
                    row_end=row_start + (len(filters) * 4) + 20, sticky='sew',\
                        padx=5)

        self.__filter_button = Button_Widget(self.get_id() + '_filter_button', \
            text='Filter', column_start=column_start, \
                column_end=int((column_end - column_start) / 2 + column_start), \
                    row_start=(row_start + (len(filters) * 4) + 21), \
                        row_end=(row_start + (len(filters) * 4) + 22))

        self.__filter_reset = Button_Widget(self.get_id() + '_reset_button', \
            text='Reset', column_start=int((column_end - column_start) / 2 + column_start) + 1,\
                column_end=column_end, row_start=(row_start + (len(filters) * 4) + 21), \
                    row_end=(row_start + (len(filters) * 4) + 22))
        
        self.__max_len_filter = 0 # the max length of the filter names in this Widget
        self.__button_width = 11 # the length of the button (Width of "Add/Remove")
        self.__textbox_width = textbox_width

    def __init_widget(self, parent):
        self.set_widget(tk.Frame(parent, height=self.get_height(), \
            width=self.get_width(), bg=self.get_bg(), \
                borderwidth=self.get_borderwidth()))
        self.init_grid()
        self.set_init()

    def __init_dropdown_widgets(self):
        """Inits the multiple Dropdown_Multiselect_Widgets.
        """
        index = 0
        self.__max_len_filter = 0
        for filter in self.__filters:
            self.__max_len_filter = max(self.__max_len_filter, len(filter))

        for filter in self.__filters:
            dropdown_widget = Dropdown_With_Button_Widget(self.get_id() + \
                    '_filter_' + str(index), filter, target_widget=self.__filter_textbox,\
                        column_start=self.get_column_start(), column_end=self.get_column_end(),\
                            row_start=self.get_row_start() + (index * 4) + 4,\
                                    pady=0, values=['', ], sticky='ew')
            
            self.__dropdown_dict[filter] = dropdown_widget
            self.add_widget(self.__dropdown_dict[filter])
            index += 1
            self.__dropdown_dict[filter].resize(self.__max_len_filter, \
                self.__textbox_width - self.__button_width - self.__max_len_filter)

    def setup(self, parent):
        """Inits the widget to a parent widget.
        """
        self.__init_widget(parent)
        self.__init_dropdown_widgets()
        self.add_widget(self.__filter_textbox)
        self.__filter_textbox.set_textbox_width(self.__textbox_width)
        self.add_widget(self.__filter_label)
        self.add_widget(self.__filter_button)
        self.add_widget(self.__filter_reset)
        self.__filter_reset.bind_function(self.reset_filters)

    def reset_filters(self):
        """Resets all selected filters in the Widget.
        """
        self.__filter_textbox.flush()
        for key in self.__dropdown_dict.keys():
            self.__dropdown_dict[key].flush()

    def clear_widget(self):
        """Removes all Dropdown_With_Button_Widgets from this object.
        """
        self.__dropdown_dict = {}
        self.__filters = []

    # setters
    def set_values_to_dropdown(self, filter_name, values):
        """Sets the values for a specific Dropdown_With_Button_Widget.

        Args:
            filter_name (string): The name of the filter, based off what was
            passed in constructor in filters.
            values (List): The List of strings of values to set for the
            Dropdown_With_Button_Widget.
        """
        self.__dropdown_dict[filter_name].set_values(values)

    def set_textbox_height(self, value):
        """Sets the height of the textbox.
        """
        self.__filter_textbox.set_height(value)

    def set_textbox_width(self, value):
        self.__filter_textbox.set_widget(value)

    # getters
    def get_filters(self):
        """Returns the view object is returned that displays all the keys
        of filter names in the Widget.
        
        This view object changes according to the changes in the dictionary.
        """
        return self.__dropdown_dict.keys()

    def get_filter_current_selected_value(self, filter):
        """Returns the current selected value in a filter, or None if
        filter arg is not found.
        """
        try:
            return self.__dropdown_dict[filter].get_current_selected_value()
        except KeyError:
            return None

    def get_filter_values(self):
        """Returns the Dictionary of Lists of selected filter values.
        """
        return self.__filter_textbox.get_dict()

    def bind_function(self, function):
        """Binds a function to the Filter button in this Widget.
        """
        self.__filter_button.bind_function(function)

class Logger_Widget(Frame_Widget):
    """A custom Textbox_Widget to be used for writing logger statements.

    see https://stackoverflow.com/questions/13318742/python-logging-to-tkinter-text-widget

    TODO: settle the private objs in this class
    """
    class Handler(logging.Handler):
        def __init__(self):
            logging.Handler.__init__(self)
            self.setLevel(logging.DEBUG)

        def emit(self, record):
            self.widget.config(state='normal')
            # Append message (record) to the widget
            self.widget.insert(tk.END, self.format(record) + '\n', record.levelname)
            self.widget.see(tk.END)  # Scroll to the bottom
            self.widget.config(state='disabled') 
            self.widget.update() # Refresh the widget

        def init_widget(self, widget):
            self.widget = widget
            self.widget.config(state='disabled')
            self.widget.tag_config("DEBUG", foreground="grey")
            self.widget.tag_config("INFO", foreground="black")
            self.widget.tag_config("WARNING", foreground="orange")
            self.widget.tag_config("ERROR", foreground="red")
            self.widget.tag_config("CRITICAL", foreground="red", underline=1)
            
            self.red = self.widget.tag_configure("red", foreground="red")

    def __init__(self, id, parent=None, column_start=0, column_end=10, row_start=0,\
        row_end=5, padx=1, pady=1, ipadx=1, ipady=1, sticky='ew', bg=None):
        super().__init__(id=str(id), parent=parent, column_start=column_start, \
            column_end=column_end, row_start=row_start, row_end=row_end, \
                padx=padx, pady=pady, ipadx=ipadx, ipady=ipady, sticky='nsew',\
                    border_color='black', borderwidth=5, bg=bg)

        self.__widget_textbox = Textbox_Widget(self.get_id() + '_textbox', \
            parent=self.get_widget(), column_start=column_start,\
                column_end=column_end, row_start=row_start, row_end=row_end,\
                    padx=padx, pady=pady, ipadx=ipadx, ipady=ipady, sticky=sticky)

        self.logging_handler = Logger_Widget.Handler()

    def __init_widget(self, parent):
        self.set_widget(tk.Frame(parent, height=self.get_height(), \
            width=self.get_width(), bg=self.get_bg(), \
                borderwidth=self.get_borderwidth()))
        self.set_init()

    def setup(self, parent):
        """Inits the widget to a parent widget.
        """
        self.__init_widget(parent)
        self.add_widget(self.__widget_textbox)
        self.init_grid()

        self.logging_handler.init_widget(self.__widget_textbox.get_widget())

    def start_logger(self, log):
        """Adds the logging handler to the logger.

        Call this at the end so that it doesn't waste time printing
        debug statements that the user shouldn't see.

        Args:
            log (Logger): The logger object taken from log.py
        """
        log.addHandler(self.logging_handler)

    def set_width(self, value):
        self.__widget_textbox.set_width(value)

    def set_height(self, value):
        self.__widget_textbox.set_height(value)
